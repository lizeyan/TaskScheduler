<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>ts.UI.task_builder API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ts.UI.task_builder</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import defaultdict, OrderedDict
from functools import reduce, partial
from itertools import product
from pathlib import Path
from typing import Union, Callable, Iterable, Tuple, List, Dict, Set

from jinja2 import Template
from loguru import logger

from ..tasks import Task, ShellTask, CallableTask, ReadFileTask, GenerateFileTask


def clear():
    global _task_target_file_dict
    global _task_builder_global_tasks
    global _task_dependency_file_dict
    global _drop_if_not_used
    _task_builder_global_tasks = set()
    _task_target_file_dict = {}
    _task_dependency_file_dict = defaultdict(list)
    _drop_if_not_used = set()
    Task.clear()


_task_builder_global_tasks = set()  # type: Set[Task]
_task_target_file_dict = {}  # type: Dict[Path, Task]
_task_dependency_file_dict = defaultdict(list)  # type: Dict[Task, List[Path]]

_drop_if_not_used = set()

reserved_keywords = [
    &#39;__dependency__&#39;, &#39;__d&#39;,
    &#39;__target__&#39;, &#39;__t&#39;,
]


def __if_func_accept_kwargs(func):
    import inspect
    x = inspect.signature(func)
    return any(_.kind == inspect.Parameter.VAR_KEYWORD for _ in x.parameters.values())


def _render(
        _original: Union[None, str, Path, Task, Iterable[Union[str, Path, Task]]],
        _params
) -&gt; Union[None, str, Path, Task, Iterable[Union[str, Path, Task]]]:
    &#34;&#34;&#34;
    render _original
    if _original is None, return None
    if _original is a list, return a list, otherwise return a str
    :param _original:
    :param _params:
    :return:
    &#34;&#34;&#34;
    if _original is None:
        return _original
    _is_list = True
    if isinstance(_original, (Task, str, Path)):
        _original = [_original]
        _is_list = False
    _ret = []
    for _item in _original:
        if isinstance(_item, str):
            _ret.append(Template(_item).render(
                **_params
            ))
        elif isinstance(_item, Path):
            _ret.append(Path(Template(str(_item)).render(
                **_params
            )))
        else:
            _ret.append(_item)
    if _is_list:
        return _ret
    else:
        return _ret[0]


def task(
        runner: Union[str, Callable], name: str = None,
        depend: Union[Iterable[Union[Path, str, Task]], Path, str, Task] = None,
        target: Union[Iterable[Union[str, Path]], Path, str, Task] = None,
        **template_kwargs,
) -&gt; Task:
    depend_files, depend_tasks, is_depend_list = __parse_depend(
        _render(depend, template_kwargs)
    )
    target_files, is_target_list = __parse_targets(
        _render(target, template_kwargs)
    )
    __d = list(map(str, depend_files))
    __t = list(map(str, target_files))
    if not is_depend_list:
        __d = __d[0] if len(__d) &gt; 0 else None
    if not is_target_list:
        __t = __t[0] if len(__t) &gt; 0 else None

    template_kwargs.update(
        __dependency__=__d, __d=__d,
        __target__=__t, __t=__t,
    )

    if isinstance(runner, str):
        ret = ShellTask(
            command=_render(runner, template_kwargs),
            name=_render(name, template_kwargs),
            dependencies=depend_tasks
        )
    elif callable(runner):
        ret = CallableTask(
            function=runner if not __if_func_accept_kwargs(runner) else partial(runner, **template_kwargs),
            name=_render(name, template_kwargs),
            dependencies=depend_tasks
        )
    else:
        raise RuntimeError(f&#34;runner should be a bash command or python Callable: {runner}&#34;)
    _task_dependency_file_dict[ret] = depend_files
    for _ in target_files:
        _task_target_file_dict[_] = ret
    logger.debug(f&#34;parsed Task {ret}&#34;)
    _task_builder_global_tasks.add(ret)
    return ret


def task_product(
        runner: Union[str, Callable], name: str = None,
        depend: Iterable[Union[Path, str, Task]] = None,
        target: Iterable[Union[str, Path]] = None,
        keep=False,
        **kwargs
) -&gt; List[Task]:
    kwargs = OrderedDict(kwargs)
    keys = list(kwargs.keys())
    values_list = list(kwargs.values())
    ret = []
    for values in product(*values_list):
        params = {k: v for k, v in zip(keys, values)}
        ret.append(task(
            runner=runner,
            name=name,
            depend=depend,
            target=target,
            **params
        ))
    if not keep:
        _drop_if_not_used.update(ret)
    return ret


def __parse_depend(
        depends: Union[Iterable[Union[str, Path, Task]], Path, str, Task] = None
) -&gt; Tuple[List[Path], List[Task], bool]:
    depend_files, depend_tasks = [], []
    is_list = True
    if depends is None:
        return depend_files, depend_tasks, False
    if isinstance(depends, (Path, str, Task)):
        depends = [depends]
        is_list = False
    for depend in depends:
        if isinstance(depend, Path):
            depend_files.append(depend.relative_to(&#39;.&#39;))
        elif isinstance(depend, Task):
            depend_tasks.append(depend)
        elif isinstance(depend, str):
            _task_resolved = Task.task(depend)
            if _task_resolved is not None:
                depend_tasks.append(_task_resolved)
            else:
                depend_files.append(Path(depend).relative_to(&#39;.&#39;))
        else:
            raise RuntimeError(f&#34;wired depend type: {depend} {type(depend)}&#34;)

    return depend_files, depend_tasks, is_list


def __parse_targets(
        targets: Union[Iterable[Union[str, Path]], str, Path] = None
) -&gt; Tuple[List[Path], bool]:
    is_list = True
    if targets is None:
        return [], False
    if isinstance(targets, (str, Path)):
        targets = [targets]
        is_list = False
    ret = []
    for target in targets:
        if isinstance(target, Path):
            ret.append(target.relative_to(&#39;.&#39;))
        elif isinstance(target, str):
            ret.append(Path(target).relative_to(&#39;.&#39;))
        else:
            raise RuntimeError(f&#34;wired target type: {target} {type(target)}&#34;)
    return ret, is_list


def _file_dependency_resolved_tasks(_tasks):
    _file_tasks = set()
    _replaced = {}
    for t in _tasks:
        dependencies_files = _task_dependency_file_dict.get(t, [])
        for f in dependencies_files:
            if f in _task_target_file_dict:
                g_task = GenerateFileTask(f, _task_target_file_dict[f])
                _file_tasks.add(g_task)
                _replaced[_task_target_file_dict[f]] = g_task
                f_task = ReadFileTask(f, [g_task])
            else:
                f_task = ReadFileTask(f)
            _file_tasks.add(f_task)
            if t in _replaced:
                _replaced[t].add_dependency(f_task)
            t.add_dependency(f_task)
    return (_tasks | _file_tasks) - set(_replaced.keys())


def _remove_unused_tasks(_tasks):
    used = reduce(
        lambda a, b: a | b,
        [_.dependencies for _ in _tasks],
        set()
    )
    logger.debug(f&#34;drop if not used: {_drop_if_not_used}&#34;)
    return _tasks - (_drop_if_not_used - used)


def _all_built_tasks():
    tasks = _task_builder_global_tasks
    tasks = _file_dependency_resolved_tasks(tasks)
    tasks = _remove_unused_tasks(tasks)
    return tasks</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ts.UI.task_builder.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear():
    global _task_target_file_dict
    global _task_builder_global_tasks
    global _task_dependency_file_dict
    global _drop_if_not_used
    _task_builder_global_tasks = set()
    _task_target_file_dict = {}
    _task_dependency_file_dict = defaultdict(list)
    _drop_if_not_used = set()
    Task.clear()</code></pre>
</details>
</dd>
<dt id="ts.UI.task_builder.task"><code class="name flex">
<span>def <span class="ident">task</span></span>(<span>runner: Union[str, Callable], name: str = None, depend: Union[Iterable[Union[str, pathlib.Path, <a title="ts.tasks.tasks.Task" href="../tasks/tasks.html#ts.tasks.tasks.Task">Task</a>]], pathlib.Path, str, <a title="ts.tasks.tasks.Task" href="../tasks/tasks.html#ts.tasks.tasks.Task">Task</a>] = None, target: Union[Iterable[Union[str, pathlib.Path]], pathlib.Path, str, <a title="ts.tasks.tasks.Task" href="../tasks/tasks.html#ts.tasks.tasks.Task">Task</a>] = None, **template_kwargs) ‑> <a title="ts.tasks.tasks.Task" href="../tasks/tasks.html#ts.tasks.tasks.Task">Task</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def task(
        runner: Union[str, Callable], name: str = None,
        depend: Union[Iterable[Union[Path, str, Task]], Path, str, Task] = None,
        target: Union[Iterable[Union[str, Path]], Path, str, Task] = None,
        **template_kwargs,
) -&gt; Task:
    depend_files, depend_tasks, is_depend_list = __parse_depend(
        _render(depend, template_kwargs)
    )
    target_files, is_target_list = __parse_targets(
        _render(target, template_kwargs)
    )
    __d = list(map(str, depend_files))
    __t = list(map(str, target_files))
    if not is_depend_list:
        __d = __d[0] if len(__d) &gt; 0 else None
    if not is_target_list:
        __t = __t[0] if len(__t) &gt; 0 else None

    template_kwargs.update(
        __dependency__=__d, __d=__d,
        __target__=__t, __t=__t,
    )

    if isinstance(runner, str):
        ret = ShellTask(
            command=_render(runner, template_kwargs),
            name=_render(name, template_kwargs),
            dependencies=depend_tasks
        )
    elif callable(runner):
        ret = CallableTask(
            function=runner if not __if_func_accept_kwargs(runner) else partial(runner, **template_kwargs),
            name=_render(name, template_kwargs),
            dependencies=depend_tasks
        )
    else:
        raise RuntimeError(f&#34;runner should be a bash command or python Callable: {runner}&#34;)
    _task_dependency_file_dict[ret] = depend_files
    for _ in target_files:
        _task_target_file_dict[_] = ret
    logger.debug(f&#34;parsed Task {ret}&#34;)
    _task_builder_global_tasks.add(ret)
    return ret</code></pre>
</details>
</dd>
<dt id="ts.UI.task_builder.task_product"><code class="name flex">
<span>def <span class="ident">task_product</span></span>(<span>runner: Union[str, Callable], name: str = None, depend: Iterable[Union[str, pathlib.Path, <a title="ts.tasks.tasks.Task" href="../tasks/tasks.html#ts.tasks.tasks.Task">Task</a>]] = None, target: Iterable[Union[str, pathlib.Path]] = None, keep=False, **kwargs) ‑> List[<a title="ts.tasks.tasks.Task" href="../tasks/tasks.html#ts.tasks.tasks.Task">Task</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def task_product(
        runner: Union[str, Callable], name: str = None,
        depend: Iterable[Union[Path, str, Task]] = None,
        target: Iterable[Union[str, Path]] = None,
        keep=False,
        **kwargs
) -&gt; List[Task]:
    kwargs = OrderedDict(kwargs)
    keys = list(kwargs.keys())
    values_list = list(kwargs.values())
    ret = []
    for values in product(*values_list):
        params = {k: v for k, v in zip(keys, values)}
        ret.append(task(
            runner=runner,
            name=name,
            depend=depend,
            target=target,
            **params
        ))
    if not keep:
        _drop_if_not_used.update(ret)
    return ret</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ts.UI" href="index.html">ts.UI</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ts.UI.task_builder.clear" href="#ts.UI.task_builder.clear">clear</a></code></li>
<li><code><a title="ts.UI.task_builder.task" href="#ts.UI.task_builder.task">task</a></code></li>
<li><code><a title="ts.UI.task_builder.task_product" href="#ts.UI.task_builder.task_product">task_product</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>